import { jsxs as h, jsx as e } from "react/jsx-runtime";
import * as u from "react";
import { Item as q, ItemText as W, Root as _, Trigger as H, Value as M, Portal as P, Content as z, Viewport as A } from "./SelectParts.js";
import { stripReactIdOfColon as D } from "../helpers/strings.js";
import { useId as R } from "../hooks/useId.js";
import { useIntersection as G } from "../hooks/useIntersection.js";
import { Box as x } from "../Box/Box.js";
import { Typography as J } from "../Typography/Typography.js";
import { Field as K } from "../Field/Field.js";
import { Flex as Q } from "../Flex/Flex.js";
import { FieldLabel as U } from "../Field/FieldLabel.js";
import { FieldHint as X } from "../Field/FieldHint.js";
import { FieldError as Y } from "../Field/FieldError.js";
const me = ({ error: c, hint: t, id: d, label: n, labelAction: i, required: a, selectButtonTitle: g, ...p }) => {
  const o = R(d), l = u.useRef(null);
  return e(K, { hint: t, error: c, id: o, required: a, children: h(Q, { direction: "column", alignItems: "stretch", gap: 1, children: [n ? e(U, { onClick: () => {
    l.current.focus();
  }, action: i, children: n }) : null, e(Z, { label: n, id: o, triggerRef: l, required: a, ...p }), e(X, {}), e(Y, {})] }) });
}, Z = ({ "aria-label": c, id: t, children: d, clearLabel: n = "Clear", customizeContent: i, disabled: a, error: g, label: p, onChange: o, onClear: l, onReachEnd: m, placeholder: C, required: B, selectButtonTitle: ee, startIcon: O, size: T = "M", value: f, triggerRef: F, ...$ }) => {
  const [y, I] = u.useState(), [k, w] = u.useState(!1), L = (r) => {
    w(r);
  }, v = (r) => {
    l && l(r), o || I("");
  }, E = `${t}-hint`, N = `${t}-error`, V = (r) => {
    o ? o(typeof f == "number" ? Number(r) : r) : I(r);
  }, b = u.useRef(null), j = R(), S = `intersection-${D(j)}`;
  G(b, (r) => {
    m && m(r);
  }, {
    selectorToWatch: `#${S}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !k
  });
  const s = (typeof f < "u" && f !== null ? f.toString() : y) ?? "";
  return h(_, { onOpenChange: L, disabled: a, required: B, onValueChange: V, value: s, ...$, children: [e(H, { ref: F, "aria-label": p ?? c, "aria-describedby": t ? `${E} ${N}` : void 0, id: t, startIcon: O, size: T, hasError: !!g, disabled: a, clearLabel: n, onClear: s && l ? v : void 0, children: e(M, { placeholder: C, textColor: s ? "neutral800" : "neutral600", children: s && i ? i(s) : void 0 }) }), e(P, { children: e(z, { position: "popper", sideOffset: 4, children: h(A, { ref: b, children: [d, e(x, { id: S, width: "100%", height: "1px" })] }) }) })] });
}, ge = u.forwardRef(({ value: c, startIcon: t, children: d, ...n }, i) => h(q, { ref: i, value: c.toString(), ...n, children: [t && e(x, { as: "span", "aria-hidden": !0, children: t }), e(J, { textColor: "neutral800", children: e(W, { children: d }) })] }));
export {
  me as SingleSelect,
  Z as SingleSelectInput,
  ge as SingleSelectOption
};
