import { jsxs as s, jsx as e } from "react/jsx-runtime";
import * as d from "react";
import { Cross as N } from "@strapi/icons";
import Q, { css as O } from "styled-components";
import { Item as F, ItemIndicator as M, ItemText as U, Group as Z, Root as ee, Trigger as re, Value as te, Portal as ne, Content as oe, Viewport as ie } from "./SelectParts.js";
import le from "../BaseCheckbox/assets/checkmark.svg.js";
import { stripReactIdOfColon as ae } from "../helpers/strings.js";
import { useId as S } from "../hooks/useId.js";
import { useIntersection as ce } from "../hooks/useIntersection.js";
import { Tag as de } from "../Tag/Tag.js";
import { Box as m } from "../Box/Box.js";
import { Typography as B } from "../Typography/Typography.js";
import { Field as se } from "../Field/Field.js";
import { Flex as he } from "../Flex/Flex.js";
import { FieldLabel as ue } from "../Field/FieldLabel.js";
import { FieldHint as pe } from "../Field/FieldHint.js";
import { FieldError as fe } from "../Field/FieldError.js";
const Le = ({ "aria-label": t, children: n, clearLabel: o = "Clear", customizeContent: l, disabled: i, error: a, hint: h, id: g, label: x, labelAction: V, onChange: p, onClear: j, onReachEnd: $, placeholder: E, required: b, selectButtonTitle: me, startIcon: z, size: A = "M", value: u, withTags: k, ...G }) => {
  const C = d.useRef(null), [v, w] = d.useState(), [W, q] = d.useState(!1), f = S(g), H = `${f}-hint`, P = `${f}-error`, X = (r) => {
    p ? p(r) : w(r);
  }, Y = (r) => () => {
    const T = Array.isArray(u) ? u.filter((I) => I !== r) : (v ?? []).filter((I) => I !== r);
    p ? p(T) : w(T);
  }, _ = (r) => {
    q(r);
  }, R = d.useRef(null), D = () => {
    R.current.focus();
  }, J = S(), y = `intersection-${ae(J)}`;
  ce(C, (r) => {
    $ && $(r);
  }, {
    selectorToWatch: `#${y}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !W
  });
  const c = typeof u < "u" && u !== null ? u : v, K = (r) => r && typeof r == "object" && r.value ? e(de, { tabIndex: -1, disabled: i, icon: e(N, {}), onClick: Y(r.value), children: r.textValue }, r.value) : null;
  return e(se, { hint: h, error: a, id: f, required: b, children: s(he, { direction: "column", alignItems: "stretch", gap: 1, children: [x ? e(ue, { onClick: D, action: V, children: x }) : null, s(ee, { onOpenChange: _, disabled: i, required: b, onValueChange: X, value: c, ...G, multi: !0, children: [e(re, { ref: R, "aria-label": x ?? t, "aria-describedby": `${H} ${P}`, id: f, startIcon: z, size: A, hasError: !!a, disabled: i, clearLabel: o, onClear: c?.length ? j : void 0, paddingLeft: k && c?.length ? 1 : 3, children: e(te, { placeholder: E, textColor: c?.length ? "neutral800" : "neutral600", children: c?.length ? k ? K : l ? l(c) : void 0 : void 0 }) }), e(ne, { children: e(oe, { position: "popper", sideOffset: 4, children: s(ie, { ref: C, children: [n, e(m, { id: y, width: "100%", height: "1px" })] }) }) })] }), e(pe, {}), e(fe, {})] }) });
}, Ve = d.forwardRef(({ value: t, children: n, startIcon: o, ...l }, i) => s(F, { ref: i, value: t.toString(), ...l, children: [o && e(m, { as: "span", "aria-hidden": !0, children: o }), e(M, { children: ({ isSelected: a, isIntermediate: h }) => e(L, { hasRadius: !0, overflow: "hidden", position: "relative", $indeterminate: h, $selected: a, zIndex: 1, height: "18px", width: "18px" }) }), e(B, { textColor: "neutral800", children: e(U, { children: n }) })] })), L = Q(m)`
  border: 1px solid
    ${({ theme: t, $selected: n, $indeterminate: o }) => n || o ? t.colors.primary600 : t.colors.neutral300};
  background-color: ${({ theme: t, $selected: n, $indeterminate: o }) => n || o ? t.colors.primary600 : t.colors.neutral0};

  ${({ theme: t, $indeterminate: n }) => n && O`
      &::after {
        content: '';
        display: block;
        position: relative;
        color: white;
        height: 2px;
        width: 10px;
        background-color: ${t.colors.neutral0};
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
      }
    `}

  ${({ $selected: t }) => t && O`
      &::after {
        content: '';
        background: url(${le}) no-repeat no-repeat center center;
        width: 100%;
        height: 100%;
        position: absolute;
      }
    `}
`, je = d.forwardRef(({ children: t, label: n, startIcon: o, values: l = [], ...i }, a) => s(Z, { ref: a, children: [s(F, { value: l, ...i, children: [o && e(m, { as: "span", "aria-hidden": !0, children: o }), e(M, { children: ({ isSelected: h, isIntermediate: g }) => e(L, { hasRadius: !0, overflow: "hidden", position: "relative", $indeterminate: g, $selected: h, zIndex: 1, height: "18px", width: "18px" }) }), e(B, { textColor: "neutral800", children: n })] }), t] }));
export {
  Le as MultiSelect,
  je as MultiSelectGroup,
  Ve as MultiSelectOption
};
