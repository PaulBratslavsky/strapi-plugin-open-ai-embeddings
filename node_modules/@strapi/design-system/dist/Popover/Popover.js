import { jsx as r, jsxs as z } from "react/jsx-runtime";
import * as o from "react";
import { useFloating as I, offset as W, shift as A, flip as K, autoUpdate as j } from "@floating-ui/react-dom";
import { FocusScope as M } from "@radix-ui/react-focus-scope";
import { useCallbackRef as T, composeEventHandlers as g } from "@strapi/ui-primitives";
import { hideOthers as U } from "aria-hidden";
import { RemoveScroll as B } from "react-remove-scroll";
import x from "styled-components";
import { DismissibleLayer as H } from "../DismissibleLayer/index.js";
import { stripReactIdOfColon as v } from "../helpers/strings.js";
import { useComposedRefs as N } from "../hooks/useComposeRefs.js";
import { useId as V } from "../hooks/useId.js";
import { useIntersection as Z } from "../hooks/useIntersection.js";
import { Box as h } from "../Box/Box.js";
import { Portal as _ } from "../Portal/Portal.js";
const ue = [
  "top",
  "top-start",
  "top-end",
  "right",
  "right-start",
  "right-end",
  "bottom",
  "bottom-start",
  "bottom-end",
  "left",
  "left-start",
  "left-end"
], q = x(h)`
  box-shadow: ${({ theme: e }) => e.shadows.filterShadow};
  z-index: ${({ theme: e }) => e.zIndices[0]};
  border: 1px solid ${({ theme: e }) => e.colors.neutral150};
`, G = o.forwardRef(({ source: e, children: s, spacing: n = 0, fullWidth: i = !1, placement: l = "bottom-start", centered: a = !1, onEscapeKeyDown: d, onPointerDownOutside: f, onDismiss: c, onFocusOutside: u, ...k }, E) => {
  const [m, R] = o.useState(null), [P, y] = o.useState(void 0), b = o.useRef(!1), { x: C, y: D, refs: S, strategy: L } = I({
    strategy: "fixed",
    placement: a ? "bottom" : l,
    middleware: [
      W({
        mainAxis: n
      }),
      A(),
      K()
    ],
    elements: {
      reference: e.current
    },
    whileElementsMounted: j
  });
  o.useLayoutEffect(() => {
    i && y(e.current.offsetWidth);
  }, [i, e]), o.useEffect(() => {
    if (m)
      return U(m);
  }, [m]);
  const w = T(c);
  o.useEffect(() => {
    const t = () => {
      w();
    };
    return window.addEventListener("blur", t), window.addEventListener("resize", t), () => {
      window.removeEventListener("blur", t), window.removeEventListener("resize", t);
    };
  }, [w]);
  const O = N(E, (t) => R(t), S.setFloating);
  return r(B, { allowPinchZoom: !0, children: r(M, {
    asChild: !0,
    loop: !0,
    // we make sure we're not trapping once it's been closed
    // (closed !== unmounted when animating out)
    trapped: !0,
    onUnmountAutoFocus: (t) => {
      t.preventDefault(), b.current || e.current?.focus({ preventScroll: !0 });
    },
    children: r(H, {
      asChild: !0,
      onEscapeKeyDown: d,
      onPointerDownOutside: g(f, (t) => {
        const p = t.detail.originalEvent, $ = p.button === 0 && p.ctrlKey === !0, F = p.button === 2 || $;
        b.current = F;
      }, { checkForDefaultPrevented: !1 }),
      // When focus is trapped, a `focusout` event may still happen.
      // We make sure we don't trigger our `onDismiss` in such case.
      onFocusOutside: g(u, (t) => t.preventDefault(), {
        checkForDefaultPrevented: !1
      }),
      onDismiss: c,
      children: r(q, { ref: O, style: {
        left: C,
        top: D,
        position: L,
        width: P || void 0
      }, hasRadius: !0, background: "neutral0", padding: 1, ...k, children: s })
    })
  }) });
}), J = ({ children: e, intersectionId: s, onReachEnd: n, ...i }) => {
  const l = o.useRef(null), a = V();
  return Z(l, n ?? (() => {
  }), {
    selectorToWatch: `#${v(a)}`,
    skipWhen: !s || !n
  }), z(Q, { ref: l, ...i, children: [e, s && n && r(h, { id: v(a), width: "100%", height: "1px" })] });
}, Q = x(h)`
  // 16 is base base size, 3 is the factor to get closer to 40px and 5 is the number of elements visible in the list
  max-height: ${3 * 5}rem;
  overflow-y: auto;
  overflow-x: hidden;

  &::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 4px;
  }

  &::-webkit-scrollbar-track {
    background: ${({ theme: e }) => e.colors.neutral0};
  }

  &::-webkit-scrollbar-thumb {
    background: ${({ theme: e }) => e.colors.neutral150};
    border-radius: ${({ theme: e }) => e.borderRadius};
    margin-right: 10px;
  }
`, me = ({ children: e, source: s, spacing: n, fullWidth: i, placement: l, centered: a, onEscapeKeyDown: d, onPointerDownOutside: f, onDismiss: c, ...u }) => r(_, { children: r(G, { source: s, spacing: n, fullWidth: i, placement: l, centered: a, onEscapeKeyDown: d, onPointerDownOutside: f, onDismiss: c, children: r(J, { ...u, children: e }) }) });
export {
  G as Content,
  ue as POPOVER_PLACEMENTS,
  me as Popover,
  J as Scrolling
};
